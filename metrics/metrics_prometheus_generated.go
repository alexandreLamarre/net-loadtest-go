// Package metrics is auto-generated by metricsgen. DO NOT EDIT.
package metrics

import (
	"fmt"
	promsdk "github.com/prometheus/client_golang/prometheus"
	"strings"
)

// toString is a helper to convert arbitrary values to string
func toString(values ...any) []string {
	if len(values) == 0 {
		return []string{}
	}
	ret := make([]string, len(values))
	for i, v := range values {
		st, ok := v.(string)
		if ok {
			ret[i] = st
			continue
		}
		it, ok := v.(int)
		if ok {
			ret[i] = fmt.Sprintf("%d", it)
			continue
		}
		it64, ok := v.(int64)
		if ok {
			ret[i] = fmt.Sprintf("%d", it64)
		}
		bt, ok := v.(bool)
		if ok {
			ret[i] = fmt.Sprintf("%t", bt)
			continue
		}
		ft, ok := v.(float64)
		if ok {
			ret[i] = fmt.Sprintf("%g", ft)
			continue
		}

		sSlice, ok := v.([]string)
		if ok {
			sb := strings.Builder{}
			sb.WriteString("[")
			for i, val := range sSlice {
				if i != 0 {
					sb.WriteString(",")
				}
				sb.WriteString("\"")
				sb.WriteString(val)
				sb.WriteString("\"")
			}
			sb.WriteString("]")
			ret[i] = sb.String()
			continue
		}

		iSlice, ok := v.([]int)
		if ok {
			sb := strings.Builder{}
			sb.WriteString("[")
			for i, val := range iSlice {
				if i != 0 {
					sb.WriteString(",")
				}
				sb.WriteString(fmt.Sprintf("%d", val))
			}
			sb.WriteString("]")
			ret[i] = sb.String()
			continue
		}

		i64Slice, ok := v.([]int64)
		if ok {
			sb := strings.Builder{}
			sb.WriteString("[")
			for i, val := range i64Slice {
				if i != 0 {
					sb.WriteString(",")
				}
				sb.WriteString(fmt.Sprintf("%d", val))
			}
			sb.WriteString("]")

			ret[i] = sb.String()
			continue
		}

		fSlice, ok := v.([]float64)
		if ok {
			sb := strings.Builder{}
			sb.WriteString("[")
			for i, val := range fSlice {
				if i != 0 {
					sb.WriteString(",")
				}
				sb.WriteString(fmt.Sprintf("%g", val))
			}
			sb.WriteString("]")
			ret[i] = sb.String()
			continue
		}

		bSlice, ok := v.([]bool)
		if ok {
			sb := strings.Builder{}
			sb.WriteString("[")
			for i, val := range bSlice {
				if i != 0 {
					sb.WriteString(" ")
				}
				sb.WriteString(fmt.Sprintf("%t", val))
			}
			sb.WriteString("]")
			ret[i] = sb.String()
			continue
		}

	}
	return ret
}

type PrometheusMetrics struct {
	*MetricLoadtestClientHttpResult
}

// NewPrometheusMetrics initializes the set of following metrics
// - LoadtestClientHttpResult  : metric recording each client response status
func NewPrometheusMetrics(reg *promsdk.Registry) (PrometheusMetrics, error) {
	m := PrometheusMetrics{
		MetricLoadtestClientHttpResult: &MetricLoadtestClientHttpResult{},
	}
	if err := m.MetricLoadtestClientHttpResult.init(reg); err != nil {
		return m, err
	}
	return m, nil
}

// MetricLoadtestClientHttpResult metric recording each client response status
type MetricLoadtestClientHttpResult struct {
	Data *promsdk.CounterVec
}

func (m *MetricLoadtestClientHttpResult) init(reg *promsdk.Registry) error {
	data := promsdk.NewCounterVec(
		promsdk.CounterOpts{
			Name: "loadtest_client_http_result_total",
			Help: "metric recording each client response status",
		},
		[]string{
			// Required attributes
			"http_status_code",
			// Optional attributes
			"http_error_type",
		},
	)
	if err := reg.Register(data); err != nil {
		return err
	}
	m.Data = data
	return nil
}

func (m *MetricLoadtestClientHttpResult) Add(
	value int64,
	httpStatusCode int64,
	attributeOpts ...AttributeLoadtestClientHttpResultOption,
) {
	options := &AttributeLoadtestClientHttpResultOptions{}
	options.Apply(attributeOpts...)
	m.Data.WithLabelValues(
		append(toString(
			httpStatusCode,
		), options.Labels()...)...,
	).Add(float64(value))
}

type AttributeLoadtestClientHttpResultOptions struct {
	httpErrorType *string
}

type AttributeLoadtestClientHttpResultOption func(*AttributeLoadtestClientHttpResultOptions)

func (o *AttributeLoadtestClientHttpResultOptions) Apply(opts ...AttributeLoadtestClientHttpResultOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeLoadtestClientHttpResultOptions) Labels() []string {
	ret := []any{}
	if o.httpErrorType != nil {
		ret = append(ret, *o.httpErrorType)
	}
	return toString(ret...)
}

// WithLoadtestClientHttpResultHttpErrorType sets the optional http_error_type attribute
// corresponding to the type of error encountered during an HTTP request
func WithLoadtestClientHttpResultHttpErrorType(httpErrorType string) AttributeLoadtestClientHttpResultOption {
	return func(o *AttributeLoadtestClientHttpResultOptions) {
		val := &httpErrorType
		o.httpErrorType = val
	}
}
